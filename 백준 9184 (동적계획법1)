#include<stdio.h>                                      # DP(동적 계획법)의 핵심인 메모이제이션을 이용한 재귀. 재귀시에 반복되는 값을 배열에 저장해놨다가 계산이 필요하면 사용 
                                                       # 메모이제이션을 사용함으로써 시간이 훨씬 단축된다.
int arr[21][21][21];

int w(int a, int b, int c) {
	
	if (a <= 0 || b <= 0 || c <= 0) return 1;                                 # a,b,c에 -50~50까지 들어올 수 있으므로 0보다 작은 구간과 20보다 큰 구간을 먼저 앞쪽에 배치하여
	else if (a > 20 || b > 20 || c > 20) return w(20, 20, 20);                # a,b,c의 범위를 0< <20으로 만들어 준다.      
	else if (arr[a][b][c] != 0) return arr[a][b][c];                          ## 메모이제이션!!! 이미 한번 계산하여 저장해놓은 값은 다시계산x, 꺼내쓰자!          
	else if (a < b && b < c) return arr[a][b][c] =	w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);
	else return arr[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);
	
}

int main() {
	int a=0, b=0, c=0;
	while (1) {
		
		scanf("%d %d %d", &a, &b, &c);
		if (a == -1 && b == -1 && c == -1) break;
		printf("w(%d, %d, %d) = %d\n",a,b,c,w(a, b, c));
	}
}


### 문제 자체는 어렵지 않으나 메모이제이션을 이용하여 재귀순환의 속도를 급격히 증가시켜주는 문제를 처음 접해보았다. 
### 재귀관련문제, 피보나치 수열과 같이 이미 계산한 값을 계속 반복해야하는 경우 메모이제이션 활용!!!
