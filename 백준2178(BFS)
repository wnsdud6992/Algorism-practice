--미로 탐색-- BFS를 이용한 최단거리 문제
BFS를 이용하면 첫번째 출력되는 값이 항상 최단거리이다.

#include <stdio.h>

typedef struct que {   //BFS를 구현하기 위해 구조체로 큐를 만들었다. 이렇게 함으로써 배열에 한번에 x,y,s가 묶인 데이터를 한 항에 저장 가능해진다.
	int x;
	int y;
	int s;
}queue;
queue q[1000000];                //queue형 q를 배열형태로 만들어서 자료구조 큐를 구현!
int map[100][100] = { 0, };

void BFS(int n, int m) {
	int x=0, y=0,s=1, front = 0, last = 0;
	
	last++;
	q[last].x = 0, q[last].y = 0, q[last].s = 1;        //처음 들어온 0,0의 값을 큐에 저장하면서 경로의 길이 s에 1을 넣어준다.
	map[0][0] = 0;

	while (front < last) {                              //큐로 BFS를 구현한 경우 이용하는 가장 큰 반복문
		front++;
		x = q[front].x, y = q[front].y, s=q[front].s;     //편하게 적기위해 x,y,s를 설정

		if (x == n - 1 && y == m - 1) {                    //최종 목표로 도착한 경우 경로 s를 출력. 그리고 break하여 반복문 탈출. 즉 가장먼저 도착한 최단거리를 구하면 탐색중단
			printf("%d", s);
			break;
		}
		if (x+1<n && map[x + 1][y] == 1) {                  //각각의 항에서 상하좌우로 이동해보고 그곳에 길이 있는 경우 그자리로 옮겨간다.
			last++;
			q[last].x = x + 1, q[last].y = y, q[last].s =s+ 1;
			map[x + 1][y] = 0;
		}
		if (y+1<m && map[x][y+1] == 1) {                    //이때 모든 경우에 if를 사용(어느 방향이 최단거리방향인지 모르기 때문에 4군대 모두 시행!)
			last++;
			q[last].x = x , q[last].y = y+1, q[last].s =s+ 1;
			map[x][y+1] = 0;
		}
		if(x-1>=0 && map[x - 1][y] == 1) {
			last++;
			q[last].x = x - 1, q[last].y = y, q[last].s =s+ 1;
			map[x - 1][y] = 0;
		}
		if (y-1>=0 && map[x][y-1] == 1) {
			last++;
			q[last].x = x, q[last].y = y-1, q[last].s =s+ 1;
			map[x][y-1] = 0;
		}
	}
}

int main() {
	int n,m,i, j;
	scanf("%d %d", &n, &m);
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++) {
			scanf("%1d", &map[i][j]);
		}
	}
	if (map[0][0] == 1) BFS(n, m);
	else printf("0");
}
