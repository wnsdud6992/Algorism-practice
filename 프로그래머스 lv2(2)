1. 주어진 노란색 개수와 갈색 개수에 맞춰 전체 사각형의 x,y값을 알아내는 문제이다.
어렵지 않지만 yellow, brown을 둘다 사용해서 구해야한다.

def solution(brown, yellow):
    answer = []
    arr=[]
    tmp=[]
    Min=2000000
    if yellow>1:
        for i in range(1,yellow//2+1):
            if yellow%i==0:
                arr.append((i,yellow//i))
        for i in arr:
            if (i[0]+2)*(i[1]+2)-yellow==brown:
                tmp=[i[0]+2,i[1]+2]
        if tmp[0]>tmp[1]:
            answer=[tmp[0],tmp[1]]
        else: answer=[tmp[1],tmp[0]]
    else:
        answer=[3,3]

    return answer
print(solution(10, 2))

2. 주어진 scoville배열을 조작하여 원하는 형태로 만드는 문제이다. 문제는 쉽게 해결했으나 효율성 부분에서 0점을 받았다. 최소값의 index를 찾는 과정에서 시간이 오래 걸리는 듯하다.
데이터 저장/삭제 시 정렬을 유지하는 자료구조인 힙 또는 우선순위 큐를 이용해야한다. 파이썬 모듈 heapq를 이용하면 배열에 저장시 시간복잡도가 O(logN)으로 굉장히 빠르다.

def solution(scoville, K):
    num=0
    while 1:
        flag=0
        m1=scoville.pop(scoville.index(min(scoville)))
        m2=scoville.pop(scoville.index(min(scoville)))
        new=m1+m2*2
        num+=1
        scoville.append(new)
        for i in scoville:
            if i<K:
                flag+=1
        if flag==0:
            break
        if len(scoville)==1:
            num=-1
            break

    return num
    
### heap자료구조 이용
 import heapq 
def solution(scoville, K):
    answer = 0
    heapq.heapify(scoville)   #heapify를 이용해 일반배열 scoville을 heap으로 바꿔준다.
    while scoville:
        first = heapq.heappop(scoville) #heappop을 이용해 scoville이란 heap에서 최소값을 뽑아온다.

        if first >= K:
            break

        if len(scoville) <= 0:
            return -1
        
        second = heapq.heappop(scoville)
        heapq.heappush(scoville, first + second * 2)   #scoville이라는 heap에 다시 연산한 값을 넣어준다. 이때 heap구조는 유지된다.
        answer += 1
    
    return answer
힙의 저장 삭제연산 시 속도는 O(logN)이므로 순서유지를 하면서 배열에 넣었다 뺏다를 하기 위해서는 heap을 이용하면 훨씬 효율적이다.
