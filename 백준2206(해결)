--벽 부수기--
단순한 BFS문제인 듯 하면서 벽을 부순후의 진행과 안부순 경우 다르게 처리해 줘야하는 함정이있다.
만약 벽을 부수고 지나간 자리를 안부수고 돌아온 길이 지나가려고 하면 이미 지나간 자리로 막혀버리곤했다.
따라서 벽을 부수기 전에 지나간 자리와 벽을 부순 후 지나간 자리를 따로 구분해줘서 3차원 배열로 구성하였다.


#include <stdio.h>

int map[1001][1001];
int visit[1001][1001][2] = { 0, };   /visit[][][0]은 벽 안부순 경우 방문,  visit[][][1]은 벽 부순 경우 방문.
typedef struct que {
	int x;
	int y;
	int s;
	int b;
}queue;

queue q[2000000];   //큐의 크기는 배열의 전체 크기보다 크게 해줘야한다. 이경우 벽 부순경우 안부순경우 나눠지므로 큐가 1000*1000*2로 설정해야 해결가능!!!
front = -1, last = -1;

void BFS(int n, int m) {
	int x, y, s, b, i, flag = 0;
	last++;
	q[last].x = 1, q[last].y = 1, q[last].s = 1, q[last].b = 1;
	visit[1][1][0] = 1;

	int next_x[] = { 0, 0, -1, 1 };
	int next_y[] = { -1, 1, 0, 0 };
	while (front < last) {
		front++;
		x = q[front].x, y = q[front].y, s = q[front].s, b = q[front].b;
		if (x == m && y == n) {
			flag = 1;
			printf("%d", s);
			break;
		}
		for (i = 0; i < 4; i++) {
			int nextx = next_x[i] + x;
			int nexty = next_y[i] + y;
			if (nextx <= 0 || nextx > m || nexty <= 0 || nexty > n ) continue;
			if (map[nexty][nextx] == 0 && b == 1 && visit[nexty][nextx][0] == 0) {    //벽을 뚫을 수있는 상태에서 0을 만나면 visit[][][0]에서 그대로 진행
				last++;
				q[last].x = nextx, q[last].y = nexty, q[last].s = s + 1, q[last].b = b;
				visit[nexty][nextx][0] = 1;
			}
			else if (map[nexty][nextx] == 0 && b == 0 && visit[nexty][nextx][1] == 0) {  //벽을 못뚫는 상태(벽이미 뚫음) 0을 만나면 visit[][][1]에서 그대로 진행
				last++;
				q[last].x = nextx, q[last].y = nexty, q[last].s = s + 1, q[last].b = b;
				visit[nexty][nextx][1] = 1;
			}
			else if (map[nexty][nextx] == 1 && b == 1 && visit[nexty][nextx][0] == 0) {  //벽을 둟을 수 있는데 벽을 만나면 벽을 뚫고 지나간다.
				last++;
				q[last].x = nextx, q[last].y = nexty, q[last].s = s + 1, q[last].b = b - 1;
				visit[nexty][nextx][1] = 1;
			}
			else if (map[nexty][nextx] == 1 && b == 0) continue;       //벽ㅁ 못뚫는데 벽을 만나면 멈춘다
		}
	}
	if (flag != 1) printf("-1");
}

int main() {
	int n, m, i, j;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) {
			scanf("%1d", &map[i][j]);
		}
	}
	BFS(n, m);
}
