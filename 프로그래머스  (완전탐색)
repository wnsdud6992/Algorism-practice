--모의고사--
1,2,3학생은 각기 찍는 방법이 다르다. 문제의 답이 answers로 주어졌을 때 각 학생이 찍어서 맞는 수가 최대인 학생을 고르는 문제.
학생의 패턴은 정해져 있기에 배열에 먼저 저장해놓고 answers의 index의 나머지값을 이용하여 찍을 수를 결정한다.
각 학생별로 맞은 문제를 다 계산했으면 제일 많이 맞은 사람을 찾는데 맞은 문제의 최대값이 되는 '사람'을 찾아야 한다.
같은 수의 정답을 맞춘 경우도 예외로 추가해줘야한다.

def solution(answers):
    answer = []
    Max=0
    sp_ans=[0,0,0]
    sp1=[1,2,3,4,5]
    sp2=[2,1,2,3,2,4,2,5]
    sp3=[3,3,1,1,2,2,4,4,5,5]
    for i in range(len(answers)):
        if sp1[i%5]==answers[i]:
            sp_ans[0]+=1
        if sp2[i%8]==answers[i]:
            sp_ans[1]+=1
        if sp3[i%10]==answers[i]:
            sp_ans[2]+=1
    for i in range(len(sp_ans)):
        if sp_ans[i]>Max:
            Max=sp_ans[i]
            answer=[i+1]
        elif sp_ans[i]==Max:
            answer.append(i+1)
    return answer
 
--소수 찾기--
n개의 낱개의 숫자가 주어졌을 때 이를 조합하여 만든 수 중에 소수를 찾는 문제이다.
n개의 낱개를 숫자가 문자열로 주어지기에 조합을 만들기 위해 리스트형으로 변환했다. 그후 permutations를 이용하여
가능한 모든 경우의 조합을 생성했다. 생성된 조합의 숫자들을 다시 문자열로 연결하고 int형으로 형변환후에 소수인지 판별하였다.
문제가 어려운것은 아니였으나 구현과정이 조금 까다롭고 제약조건이 좀 있었다고 느껴졌던 문제이다.
문자열을 리스트로, 리스트를 문자열로 재변환하는 과정을 처음 해보았다.
 
from itertools import permutations
def solution(numbers):
    arr=list(map(int,','.join(numbers).split(',')))
    answer = 0
    ppp=[]
    
    for i in range(1,len(numbers)+1):
        per=permutations(arr,i)
        for j in per:
            tmp=''
            for k in j:
                tmp+=str(k)              #조합으로 이루어진 튜플 값 j를 str형태인 tmp로 변환후 int형으로 변환
            tmp=int(tmp)
            flag=0
            for k in range(2,tmp//2+1):
                if tmp%k==0:
                    flag+=1
                    break
            if tmp>1 and flag==0 and tmp not in ppp:
                ppp.append(tmp)
                answer+=1
    return answer
print(solution("011"))
