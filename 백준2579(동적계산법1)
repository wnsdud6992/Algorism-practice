--계단오르기--
어려움, 점화식을 구하기 상당히 까다롭다.

#include <stdio.h>

int Max(int a, int b) {
	return a > b ? a : b;
}

int main() {
	int n, arr[300],dp[300], i ,a;                //dp문제(동적계획법)에서는 기본적으로 메모제이션할 배열dp[]가 필요하다.
	scanf("%d", &n);
	for (i = 0; i < n; i++) {
		scanf("%d", &arr[i]);
	}
	dp[0] = arr[0];
	dp[1] = Max(arr[1], arr[0] + arr[1]);
	dp[2] = Max(arr[0] + arr[2], arr[1] + arr[2]);      //3번째 칸까지는 1칸과 2칸의 단순 비교로 지정
	for (i = 3; i < n; i++) {
		dp[i] = arr[i] + Max(dp[i - 2], arr[i - 1]+dp[i - 3]);   //4번째칸 이상부터는 도착지점의 스텝은 무조건 포함하므로 arr[i]는 더해주고, 1칸 밑에를 밟고 왔을 경우 
	}                                                          (이 경우 전 스텝은 무조건 2칸을 건너뛰어서 왔어야 한다) 따라서 arr[i-1]에 이 스텝의 2칸전까지의 총합인 dp[i-3]을 더해준다
                                                             // 두칸 밑에를 밟고 목적지에 왔을 경우 그 스텝까지의 총 합을 더해주면 된다.
	printf("%d", dp[n - 1]);
}

//점화식이 어려웠던 것은 아니나 조건을 어떻게 구현해야할까 고민하게 되었다. 다시한번 동적계획법은 전체문제를 작은단위로 잘라서 각 계산과정을 배열에 더해놨다가 한번에 합침을 확인!!
