--BFS,DFS-- 가장 간단한 BFS,DFS 문제이다.
DFS는 스택이나 재귀를 이용하여 깊이 우선 탐색 법
BFS는 큐를 이용하여 너비 우선 탐색 법


#include <stdio.h>

int graph[1001][1001] = { 0, };           //주어진 그래프를 인접행렬로 구현하였다. 데이터양이 크지 않다면 좋은 방법!
int DFSvisit[1001] = { 0, };              // DFS, BFS함수를 실행시킬 때 그래프가 그 노드를 방문했는지 기록하기 위해 배열로 방문록을 만들어 놓음
int BFSvisit[1001] = { 0, };
int queue[1001] = { 0, };                 //BFS함수 제작 시 큐를 이용해야 하므로 배열을 이용하여 큐를 구현

void DFS(int n, int v) {                  // DFS함수의 핵심은 재귀를 이용하여 아들 노드에서도 진행     
	int i;
	DFSvisit[v] = 1;                        // start노드의 값을 방문록에 기록하고 출력한다. 즉 재귀를 이용하였기에 아들노드를 start 매개변수로 넘겨주게 되면
	printf("%d ", v);                       // 아들 노드 또한 똑같이 방문록에 기록되고 출력된다.

	for (i = 1; i <= n; i++) {              //입력받는 index값이 1부터 n까지 이므로 for문에 주의
		if (graph[v][i] == 1 && DFSvisit[i]==0) {     // 부모 노드의 아들노드중 방문을 한번도 하지 않은 노드를 찾아가 똑같이 DFS를 진행!
			DFS(n, i);
		}
	}
}

void BFS(int n, int v) {                  // BFS는 큐에 아들 노드를 전부 넣고 하나씩 꺼내면서 각각의 아들 노드를 큐에 추가하는 식으로 구현
	int i, front = 0, l = 0,pop;   
	BFSvisit[v] = 1;                        //BFS의 방문록에 start노드를 기록하고 이를 큐에 대입 후 출력
	queue[l] = v;
	printf("%d ", v);
	l++;                                     //l은 큐에 존재하는 가장 마지막 인덱스를 가르킨다.
	while (front < l) {                      //front는 큐의 가장 앞에 존재하는 인덱스를 가르키는데 front와 l이 같아지게 되면 큐가 비워진 것이고 그래프를 다 순회한 것이다.
		pop = queue[front];                    //pop에 큐의 가장 앞에 존재하는 값을 빼오고 front를 증가시킨다.
		front++;
		for (i = 1; i <= n; i++) {             // front에 존재한 값의 아들 노드중 방문하지 않은 것들을 찾아 출력하고, 큐에 대입한다. 대입 시 l은 증가시켜준다.  
			if (graph[pop][i] == 1 && BFSvisit[i] == 0) {
				printf("%d ", i);              //구현한 bfs는 큐에 front값을 출력을 먼저하고 pop하는 형태로 구성되어있다.
				queue[l] = i;
				l++;
				BFSvisit[i] = 1; 
			}
		}
	}
}

int main() {
	int n, m, v, i, a, b;
	scanf("%d %d %d", &n, &m, &v);
	for (i = 0; i < m; i++) {
		scanf("%d %d", &a, &b);
		graph[a][b] = graph[b][a] = 1;
	}
	DFS(n, v);
	printf("\n");
	BFS(n, v);
}
