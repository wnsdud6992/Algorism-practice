--퇴사-- 브루트포스문제로 분류되어있었지만 다이나믹 프로그래밍으로 풀었다.
n개의 날짜에 각각 a일이 걸리는 일과 그 일을 진행하면 받는 보수 b가 적혀있다. n일동안 최고 보수를 받기 위한 일을 선택한 경우 최고보수는?

앞에서부터 브루트포스로 모든 경우를 돌보려고 하려니 n개의 날짜에 따라 for문을 굉장히 여러번 돌아야 할꺼같아 시간문제로 막혔다.
그래서 뒤에서부터 따져보았다(dp문제는 대부분 마지막부터 일반화 하는 작업이 많다.)
맨 마지막날은 무조건 1일 걸리는 작업이 아닌이상 수행하지를 못한다. 마지막보다 전에 존재하는 날에는 a일이 걸리는 일을 해결하고 나서 다음날부터는 
저장해놓았던(메모지에이션 활용) max값을 더하여 이 값이 a일 걸리는 일이 존재하는 날 다음날의 max값보다 크다면 그날의 max배열에 값을 저장.
따라서 max[0]에는 n일에 대한 최대 보수가 저장되게 된다.

n=int(input())
arr=[list(map(int,input().split())) for _ in range(n)]
max=[0 for _ in range(n)]
if arr[n-1][0]==1:         #마지막날은 무조건 1일 걸리는 일이 아닌이상 진행불가
    max[n-1]=arr[n-1][1]
for i in range(n-2,-1,-1):   #마지막날 이전날들을 하나씩 돌면서 max배열을 채워준다.
    sum=0
    if arr[i][0]<n-i:        #임의의 날의 일이 남은 기간동안 수행하고도 날짜가 남는경우(남은 날짜의 max값을 더해서 이전과 비교)
        sum=arr[i][1]+max[i+arr[i][0]]
        if sum>max[i+1]:
            max[i]=sum
        else: max[i]=max[i+1]
    elif arr[i][0]==n-i:      #임의의 날의 일이 남은 기간동안 수행하면 딱 떨어지는 경우(이전 값과 현재 수행한 보수를 비교)
        sum=arr[i][1]
        if sum>max[i+1]:
            max[i]=sum
        else: max[i]=max[i+1]
    else: max[i]=max[i+1]     #임의의 날의 일이 남은 날짜동안 수행하지 못하는 경우(이전 값을 그래도 max에 )
print(max[0])
