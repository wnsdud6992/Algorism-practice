--연구소--
브루트포스를 이용하여 모든 0인 지점에 벽을 세우는 경우를 고려해주고, 각 경우에 2(바이러스)를 퍼뜨리는 것을 dfs나 bfs를 이용하여 구현해야 한다.
배열을 복사할때 기존 원본을 그대로 두고싶다면 deepcopy를 이용해야 한다. splicing을 이용하는 것은 파이썬 list특성상 같은 주소를 바라보게 되므로
문제가 발생한다.


from itertools import combinations
from collections import deque
import copy                     #deepcopy를 이용하기 위한 import
n,m=map(int,input().split())
arr=[list(map(int,input().split())) for _ in range(n)]
maxx=0
q=deque()

def bfs(tmp):
    nx=[1,-1,0,0]
    ny=[0,0,1,-1]
    while q:
        for i in range(len(q)):
            y,x=q.popleft()
            for i in range(4):
                n_y=ny[i]+y
                n_x=nx[i]+x
                if n_x<0 or n_x>=m or n_y<0 or n_y>=n or tmp[n_y][n_x]==1 or tmp[n_y][n_x]==2: continue
                if tmp[n_y][n_x]==0:
                    tmp[n_y][n_x]=2
                    q.append((n_y,n_x))

zero=[]
k=[]
for i in range(n):
    for j in range(m):
        if arr[i][j]==0:
            zero.append((i,j))
        elif arr[i][j]==2:
            k.append((i,j))
a=list(combinations(zero,3))


for i in a:
    q=deque()
    tmp=copy.deepcopy(arr)         #tmp를 단순히 arr[:]로 저장할 경우 tmp를 고치는 순간 arr도 변하게 된다. 따라서 copy.deepcopy함수를 이용해서 완전 새로운 배열로 복사해야한다.
    tmp[i[0][0]][i[0][1]]=1
    tmp[i[1][0]][i[1][1]]=1
    tmp[i[2][0]][i[2][1]]=1
    for j in k:
        q.append(j)
    bfs(tmp)
    total=0
    for y in range(n):
        for x in range(m):
            if tmp[y][x]==0:
                total+=1
    if total>maxx: maxx=total
print(maxx)
