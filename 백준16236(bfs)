--아기상어--
처음부터 문제를 제대로 이해했으면 이렇게 오래 걸리지 않았을 것이다. 이해를 잘못해 나름의 조건을 추가하여 구현이 복잡해졌었는데 그 결과 테스트케이스에서부터 막히기 시작했다.

문제 구현은 어렵지 않다. 아기상어 주변으로 bfs탐색을 하여 상어보다 몸집이 작은 물고기들을 임시 배열에 저장한다. 먹을 수 있는 물고기의 수가 다수라면 위에서부터, 왼쪽부터
먹는다고 했는데 이 의미는 다르게 말하면 먹을 수 있는 물고기들의 좌표를 sorting하였을 때 가장 앞에 나오는 물고기부터 먹으라는 이야기이다. 이를 이용하여 매번 sorted함수를 사용해
먹은 물고기위치를 반환하고 그 곳으로 상어를 이동시킨다. 먹은 횟수를 기록했다가 상어 사이즈보다 많이 먹었을 경우 사이즈를 키우고 이렇게 반복한다.
이때 주의할 점이 매 bfs시 상어가 탐색한 공간을 저장하기 위해 기존 arr배열을 복사하고 상어가 지나온 자리를 '7로' 표시했었는데 상어 사이즈가 7이 되면 지나온 자리에 고기가 있다고 판단
하기 때문에 무한루프를 돌게된다. 따라서 지나온 자리를 100으로 설정해서 무한루프를 방지한다.

코딩테스트 시 가장먼저 문제를 정확히 읽고 파악하는 것이 우선적으로 집중해야겠다. 코드를 못짜서 시간이 많이 걸린다기보다 매번 문제를 잘못 파악하던지, 조건을 실수하여 오류가 발생하는
경우가 대다수이기 때문이다.


from collections import deque
import copy
q=deque()
n=int(input())
arr=[list(map(int,input().split())) for _ in range(n)]
total=0
s=2
dx=[0,-1,1,0]
dy=[-1,0,0,1]
for i in range(n):
    for j in range(n):
        if arr[i][j]==9:
            q.append((i,j,0))
            arr[i][j]=0

def bfs(s,ar):
    global total
    temp=[]
    while q:
        for k in range(len(q)):
            y,x,t=q.popleft()
            for i in range(4):
                ny=y+dy[i]
                nx=x+dx[i]
                nt=t+1
                if ny<0 or ny>=n or nx<0 or nx>=n or ar[ny][nx]>s: continue
                if ar[ny][nx]>0 and ar[ny][nx]<s:
                    temp.append((ny,nx,nt))
                elif ar[ny][nx]==0 or ar[ny][nx]==s:
                    ar[ny][nx]=100
                    q.append((ny,nx,nt))
        if temp: 
            temp=sorted(temp)
            total+=temp[0][2]
            arr[temp[0][0]][temp[0][1]]=0
            return temp[0][0], temp[0][1]
        
    return -1,-1
flag=0
eat=0
while 1:
    ar=copy.deepcopy(arr)
    y,x=bfs(s,ar)
    if y==-1 and x==-1:
        flag+=1
        break
    else: 
        eat+=1
        q=deque()
        q.append((y,x,0))
    if flag>0:
        break
    else: 
        if eat==s:
            eat=0
            s+=1
print(total)

          
      
