--다음 순열--
 n개의 수열이 주어지면 다음으로 올 수열을 출력하는 문제이다.
 블루트포스인만큼 모든경우에 대해 빠짐없이 진행하는것이 중요하다.
 실수점
 1. 점화식을 찾고 일반화하는 과정에서 swap대상을 실수하지 말것.
 2. 점화식을 for문으로 돌리는 경우 초기값 혹은 for문에 들어가 있지 않는 가장 단순한 경우가 빠져있는지 확인할 것.

#include <stdio.h>
void swap(int* a, int* b) {       //swap함수이다. c언어에서는 swap을 위해서 포인터를 이용하고 함수 이용시 주소를 넘겨줘야한다.
	int temp = *b;
	*b = *a;
	*a = temp;
}

int arr[10000];

int main() {
	int n, i, j = 0, tmp = 0, k = 0,flag=0;
	scanf("%d", &n);
	for (i = 0; i < n; i++) {
		scanf("%d", &arr[i]);
	}
	if (n == 1) {                //실수점 두번째 내용이다. 규칙을 찾아 for문으로 돌리는데 i=n-2부터 시작한다. 즉 2개 이상이 들어왔다는 가정에서 돌린 것이므로
		flag++;                    // 숫자 1개로 수열을 이룬경우를 따로 챙겨줘야한다.
	}
	else {
		for (i = n - 2; i >= 0; i--) {
			if (i == 0 && arr[i] >= arr[i + 1]) flag++;      //모든 testcase에 대해서 항상 확인할 것. 가장 마지막에 오는 수열일 경우 어떻게 처리하는지 확인해야한다.
      
			else if (arr[i] >= arr[i + 1]) continue;

			else if (arr[i] < arr[i + 1]) {
				for (int a = n - 1; a >= i + 1; a--) {         //실수점 첫번째이다. 단순히 arr[i]<arr[i+1]인 지점을 찾고나서 arr[i]를 arr[n-1]과 바꿔주었는데
					if (arr[i] < arr[a]) {                       // arr[i]와 바꿔줘야 할 숫자는 arr[i]보다 크지만 나머지중에 가장 작은수이므로 이를 찾는과정이 필요하다.
						swap(&arr[i], &arr[a]);
						break;
					}
				}
				k = n - 1;
				j = i + 1;
				while (j <= k) {
					swap(&arr[j], &arr[k]);
					j++, k--;
				}
				break;
			}
		}
	}
	
	if (flag == 0) {
		for (i = 0; i < n; i++) {
			printf("%d ", arr[i]);
		}
	}
	else printf("-1");
	
	
}
