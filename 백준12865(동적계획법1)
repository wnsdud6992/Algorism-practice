--냅색문제-- 배낭에 정해진 무게까지 여러개의 물건중 최대무게보다 가벼우면서 최대한의 가치를 나타내도록 물건 뽑는 알고리즘
동적계획법의 유명한 문제이나 이 알고리즘을 모르고 있다면 거의 풀수가 없을것 같다.
풀이방법은 가방의 최대무게가 1부터 max까지 증가함에 따라 각 최대무게에 따른 추가 물건별 최대 가치값을 저장한다. 


#include <stdio.h>

int Max(int a, int b) {
	return a > b ? a : b;
}

int dp[101][100001] = {0,};

int main() {
	int n, k, w[101], v[101], i, j;
	scanf("%d %d", &n, &k);
	for (i = 1; i <= n; i++) {
		scanf("%d %d", &w[i], &v[i]);
	}

	for (i = 1; i <= n; i++) {                      //모든 물건에 대해 1부터 최대 무게까지 순환해야 하기에 이중 for문으로 구성
		for (j = 1; j <= k; j++) {
			if (j - w[i] >= 0) {                        // j번째 무게가 해당 물건의 무게보다 크다면 (해당 물건의 가치+해당물건의 무게를 뺀 나머지 무게로 만들수 있는 최대 가치)와 
				dp[i][j] = Max(v[i] + dp[i - 1][j - w[i]], dp[i - 1][j]);    //(j번째 무게에서 해당물건을 제외하고 만들 수 있는 최대가치)를 비교하여 큰값을 dp[i][j]에 저장
			}
			else dp[i][j] = dp[i - 1][j];               //j번째 무게가 해당물건보다 작다면 j번째 무게를 만들 수 있는 최대 무게(이전 물건들을 전부 고려한 최대값)을 저장
		}
	}
	printf("%d", dp[n][k]);                         //dp[n][k]에는 n개의 물건을 차례로 고려했을때 k무게를 만들수 있는 최대 가치가 저장되어있다.

}


처음보는 냅색문제라 상당히 어려웠다. 표를이용하여 이런식으로 풀수 있을 줄은 몰랐다
