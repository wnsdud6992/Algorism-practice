--숨바꼭질-- 언니는 N, 동생은 K에 위치. 언니가 +1,-1,*2를 하여 최단횟수로 동생잡기.
기본적인 BFS알고리즘을 이용하는 문제이다. 언니의 항에서 +1,-1,*2한걸 큐에 넣어서 BFS탐색을 하여 가장 먼저 도착한 것이 최단횟수이다.
2가지 포인트가 있다. 첫번째로 +1,-1,*2한경우 범위를 생각해 주어야 하는데 -1한경우고 0보다는 크거나 같아야 하고 +1한경우는 K보다는 작아야 한다. 
*2한경우는 K+1보다는 작거나 같아야 하는데 K+2가 되어 -1 두번할바에 이전에 -1을 하고 *2를 하면 K가 되기 때문이다.
두번째로 이렇게 구현한 bfs는 정답에 도달은 하지만 큐에 들어가는 메모리가 어마어마해진다. 한개의 항마다 3개씩 큐에 추가로 들어오는데 수가 커져 100000이 넘어가도
+1,-1 두개씩 들어옴으로 기하급수적으로 큐에 메모리가 많이 차지한다. 이때 나름 메모지에이션의 방법을 사용한다. 언니가 동생으로 가는 길에 이미 들렸다 하는 장소에
도착한 경우(visit배열에 0이 아닌경우) 그 자리에서 +1,-1,*2를 했을 것이므로 바로 건너뛰게 설정한다. 이렇게 함으로써 각 항이 두번 중복되어 계산되는 일 없이
메모리를 효율적으로 사용하여 탐색 할 수 있게 된다.

#include <stdio.h>

int map[100000] = { 0, };
int visit[100000] = { 0, };
typedef struct que {
	int x;
	int s;
}queue;
queue q[100000];
int front = -1, last = -1;

void BFS(int k) {
	int x, s;

	while (front < last) {
		front++;
		x = q[front].x, s = q[front].s;
		if (x == k) {
			printf("%d", s);
			break;
		}
		
		if (x - 1 >= 0 && visit[x-1]==0) {           //visit[]배열에서 이미 들렸던 곳은 다시 들리지 않아 큐에 메모리를 아낀다.
			last++;
			q[last].x = x - 1, q[last].s = s + 1;
			visit[x - 1] = 1;
		}
		if (x + 1 <= k && visit[x+1]==0) {
			last++;
			q[last].x = x + 1, q[last].s = s + 1;
			visit[x + 1] = 1;
		}
		if (x *2 <= k+1 && visit[x*2]==0) {
			last++;
			q[last].x = x*2, q[last].s = s + 1;
			visit[x *2] = 1;
		}
	}
}

int main() {
	int i, j, n, k;
	scanf("%d %d", &n, &k);
	map[k] = 1;
	last++;
	q[last].x = n, q[last].s = 0;
	visit[n] = 1;
	BFS(k);
}
