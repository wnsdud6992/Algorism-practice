--네트워크--
bfs를 이용하여 주어진 전체 컴퓨터 수와 연결 관계 배열을 파악하여 형성된 네트워크의 수를 출력하는 문제이다.
bfs로 연결된 네트워크를 이어 하나로 확인하여 이렇게 연결된 개수가 몇개인지 파악하면 된다.
그러나 한가지 실수했던 것은 연결된 네트워크의 개수만 셀 것이 아니라 다른 어떤 컴퓨터랑도 연결이 안된 컴퓨터가 존재하는지도 확인해주어야 했다.
따라서 컴퓨터의 배열을 만들어 네트워크가 형성된 컴퓨터는 제거하고 형성된 네트워크 개수를  세고, 이 네트워크에 끼지 못한 나머지 컴퓨터 수를 더해
전체 네트워크 개수를 구하였다


from collections import deque
q=deque()
def bfs(n, computers,num):
    tmp=1
    while q:
        y,x=q.popleft()
        computers[y][x]=computers[x][y]=0
        if y in num:
            num.remove(y) 
        if x in num:
            num.remove(x)     
        for k in range(n):
            if computers[x][k]==1:
                q.append((x,k))
            
def solution(n, computers):
    num=[]
    answer = 0
    for i in range(n):
        num.append(i)
        computers[i][i]=0
    for i in range(n):
        for j in range(n):
            if computers[i][j]==1:
                q.append((i,j))
                bfs(n,computers,num)
                answer+=1
    return answer+len(num)
    
    
    
 --다른풀이
visit배열을 이용한 다른 사람의 풀이이다. 사실 나의 풀이는 컴퓨터가 200대이기에 시간내에 풀 수 있었지만 컴퓨터 리스트를 순회하는 과정이 포함되어 있기에
이를 확인하는 절차를 거치면서 시간이 상당히 소요될 수 있다.
다음과 같이 visit리스트를 만들어 각 컴퓨터를 0으로 초기화하고 방문했다면 1을 넣는다면 bfs순회시 다시 방문할일도 없고 방문 안했던 곳도 파악이 가능하여
answer에 더할 수 있게 된다. visit배열을 이용하는 방법을 고려해보아야겠다

def visit(k, graph, visited):
    visited[k] = 1
    for i in range(len(graph[k])):
        if visited[i] == 0 and graph[k][i] == 1:
            visit(i, graph, visited)

def solution(n, computers):

    visited = [0] * n

    answer = 0

    for i in range(n):
        if visited[i] == 0:
            visit(i, computers, visited)
            answer += 1

    return answer
