--유기농 배추-- 2차원 행렬에서 입력받은 인덱스는 1인데 이런 1이 상하좌우로 붙어 한 그룹을 만들때 전체 배열 안에서 몇개의 그룹이 존재하는지 파악하는 문제
바이러스 문제와 많이 흡사하다. 대신 이 문제는 그룹내의 인덱스 수를 구하기보다 총 그룹수를 구하는데 이를 t번 반복해야한다.

#include <stdio.h>

int map[50][50] = { 0, };         // 전체 2차원 배열(배추밭)을 의미한다
int m, n;                         // BFS함수에서 인덱스값이 범위(n,m을 넘어가는지 확인 하기 위해 글로벌 함수로 지정)

void BFS(int i, int j) {          // BFS함수로 매개변수가 밭의 가로 세로 인덱스를 의미. 
	if (map[i][j] == 1) {
		map[i][j] = 0;                // 매개변수로 받은 장소에 배추가 존재하면 0을 저장하고 밭의 범위를 벗어나지 않으면 상하좌우로 BFS함수를 실행
		if (i - 1 >= 0) BFS(i - 1, j); //이렇게 함으로써 1을 발견할 시 인접한 배추를 모두 찾아 낼 수 있고 지나간 배추자리는 0으로 표시함
		if (i + 1 < m) BFS(i + 1, j);
		if (j - 1 >= 0) BFS(i , j-1);
		if (j +1 <n) BFS(i , j+1);
	}
}

int main() {
	int t, i, j,k,a, b, num,c,d;
	scanf("%d", &t);
	for (c = 0; c < t; c++) {             //테스트 케이스만큼 반복해야 하므로 t번 반복
		scanf("%d %d %d", &m, &n, &k);
		for (d = 0; d < k; d++) {
			scanf("%d %d", &a, &b);
			map[a][b] = 1;
		}
		num = 0;                            // 새로운 테스트 케이스마다 전체 그룹수가 달라지므로 num값을 초기화, 하나의 테스트 케이스에 대해 for문으로 한번 순회하게되면
		for (i = 0; i < m; i++) {           // 밭이 전부 다시 0이 되기에 다시 사용자로부터 입력받을 수 있게 초기화 되어있다.
			for (j = 0; j < n; j++) {
				if (map[i][j] == 1) {
					BFS(i, j);
					num++;                        // BFS가 끝나면 1을 찾은 배추와 인접한 배추들은 전부 찾아 0으로 만들어줫기에 1개 그룹을 찾은셈이므로  NUM에 1을 더함
				}
			}
		}
		printf("%d\n", num);
	}
	
}
